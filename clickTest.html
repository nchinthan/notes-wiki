<div id="parentContainer" style="border: 2px solid blue; padding: 20px;">
    <p>This is a paragraph.</p>
    <div>
        <span class="clickable-item" data-id="item1">Clickable Item 1</span>
        <ul>
            <li>List Item A</li>
            <li>List Item B <strong class="clickable-item" data-id="item2">Clickable Item 2 (Nested)</strong></li>
        </ul>
    </div>
    <button>A Button</button>
</div>

<div id="clickInfo">Click info will appear here.</div>



<div id="myElement" style="border: 2px solid green; padding: 50px; margin: 20px;">
    Right-click here to see the context menu event.
</div>

<div id="output" style="border: 1px solid #ccc; padding: 10px; margin: 20px;">
    Event info will appear here.
</div>



<div id="customContextMenu" style="
    display: none;
    position: absolute;
    background-color: #f9f9f9;
    border: 1px solid #d3d3d3;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 1000;
    padding: 8px;
    min-width: 120px;
">
    <div style="padding: 4px; cursor: pointer;" onmouseover="this.style.backgroundColor='#ddd';" onmouseout="this.style.backgroundColor='#f9f9f9';" >Add link</div>
    <div style="padding: 4px; cursor: pointer;" onmouseover="this.style.backgroundColor='#ddd';" onmouseout="this.style.backgroundColor='#f9f9f9';" >Add heading</div>
    <div style="padding: 4px; cursor: pointer;" onmouseover="this.style.backgroundColor='#ddd';" onmouseout="this.style.backgroundColor='#f9f9f9';" > red color </div>
</div>



<script>


const parentContainer = document.getElementById('parentContainer');
const clickInfoDiv = document.getElementById('clickInfo');

// Store this at a higher scope
let lastSelection = null;

// When you first show the custom menu (probably on mouseup/contextmenu)
parentContainer.addEventListener('mouseup', (e) => {
  const selection = window.getSelection();
  if (selection.toString().length > 0) {
    lastSelection = selection.getRangeAt(0).cloneRange(); // Store the range
  }
});


// Improved highlight function
function highlightSelection( styles = {}) {
        console.log("btn clicked --- ")
    console.log(styles);
    if (!lastSelection || lastSelection.collapsed){
        console.log("failed high")
         return false;
    }
    // Check if selection is within single text node
    if (lastSelection.startContainer === lastSelection.endContainer ) {
        console.log("success")
        const span = document.createElement('span');
        span.className = 'text-highlight'; // Add class for styling
        Object.assign(span.style, styles);
        
        try {
            lastSelection.surroundContents(span);
            return true;
        } catch (e) {
            // Fallback for partial node selections
            const content = lastSelection.cloneContents();
            span.appendChild(content);
            lastSelection.deleteContents();
            lastSelection.insertNode(span);
            return true;
        }
    }
    console.log("failed high")
    return false;
}

const style1 = {
            backgroundColor: '#ffeb3b',
            transition: 'all 0.3s ease',
            boxShadow: '0 0 0 2px rgba(255,235,59,0.3)'
        }


function AddColorOnClick(e) {
    e.stopPropagation();
    try {
        const success = highlightSelection(style1 );
        
        if (!success) {
            console.warn("Highlighting failed");
        }
    } catch (error) {
        console.error("Error highlighting selection:", error);
    }
    
    hideCustomMenu();
    
}

function getCssPath(element) {
    if (!element) return '';
    
    if (element.id) {
        return `#${element.id}`;
    }
    
    const path = [];
    let current = element;
    
    while (current && current.nodeType === Node.ELEMENT_NODE) {
        let selector = current.nodeName.toLowerCase();
        
        if (current.id) {
            path.unshift(`#${current.id}`);
            break;
        } else {
            let sibling = current;
            let nth = 1;
            
            while (sibling.previousElementSibling) {
                sibling = sibling.previousElementSibling;
                if (sibling.nodeName.toLowerCase() === selector) {
                    nth++;
                }
            }
            
            if (nth !== 1) {
                selector += `:nth-child(${nth})`;
            }
        }
        
        path.unshift(selector);
        current = current.parentNode;
    }
    
    return path.join(' > ');
}


    function contextMenuOptions(dom){
        clickInfoDiv.innerHTML = dom.parentElement.dataset.target ;
    }


    function setContextMenuEventlisteners(){
        const customMenu = document.getElementById('customContextMenu');
        customMenu.children[2].addEventListener('click', (e) => AddColorOnClick(e));

        // customMenu.childNodes.forEach((child)=>{
        //     child.addEventListener('click',(e)=>{
        //         e.stopPropagation();
        //         contextMenuOptions(child);
        //         hideCustomMenu();
        //     })
        // })
    }
    setContextMenuEventlisteners()
    
    let target = null;
    parentContainer.addEventListener('click', (event) => {
        // event.target is the actual element that was clicked
        const clickedElement = event.target;
	
        // event.currentTarget is the element the listener is attached to (parentContainer)
        const listenerElement = event.currentTarget;
	    target = clickedElement;
        let info = `
            <p><strong>Click Event Captured!</strong></p>
            <p>Listener attached to: <code>#${listenerElement.id}</code></p>
            <p>Original element clicked (<code>event.target</code>):</p>
            <ul>
                <li>Tag Name: <code>${clickedElement.tagName}</code></li>
                <li>ID: <code>${clickedElement.id || 'N/A'}</code></li>
                <li>Class: <code>${clickedElement.className || 'N/A'}</code></li>
                <li>Text Content: "${clickedElement.textContent.trim().substring(0, 30)}..."</li>
            </ul>
        `;

        // You can add conditions to check if the clicked element is one you care about
        if (clickedElement.classList.contains('clickable-item')) {
            const dataId = clickedElement.dataset.id; // Access custom data attributes
            info += `<p style="color: green;">Detected a specific 'clickable-item'! Data ID: <strong>${dataId}</strong></p>`;
        } else if (clickedElement.tagName === 'BUTTON') {
             info += `<p style="color: purple;">A button was clicked!</p>`;
        } else {
             info += `<p style="color: orange;">A non-specific element was clicked.</p>`;
        }

        clickInfoDiv.innerHTML = info;

        // Optional: If you want to stop the event from bubbling further up the DOM
        // event.stopPropagation();
    });


    const myElement = document.getElementById('myElement');
    const outputDiv = clickInfoDiv;

    if (myElement) {
        parentContainer.addEventListener('contextmenu', (event) => {
            // 1. Prevent the default browser context menu from appearing
            event.preventDefault();

            // 2. Get information about the click
            const clickX = event.clientX; // X coordinate relative to the viewport
            const clickY = event.clientY; // Y coordinate relative to the viewport
            const targetElement = event.target; // The element that was right-clicked

            outputDiv.innerHTML = `
                <p><strong>Context Menu Event!</strong></p>
                <p>Right-clicked on: <code>${targetElement.tagName}</code> (ID: <code>${targetElement.id || 'N/A'}</code>)</p>
                <p>Coordinates (Viewport): X=${clickX}, Y=${clickY}</p>
            `;



            // 3. You can now display your custom context menu
            // (e.g., create a div, position it at clickX, clickY, and show it)
            // For example, a simple floating div:
            const customMenu = document.getElementById('customContextMenu');
            customMenu.dataset.target = getCssPath(targetElement);
            if (customMenu) {
                customMenu.style.display = 'block';
                customMenu.style.left = `${clickX}px`;
                customMenu.style.top = `${clickY}px`;
                // Optional: Add menu items and their click handlers here
            }

            // 4. (Optional) Hide the custom menu when the user clicks elsewhere
            //    A common pattern is to add a click listener to the document
            //    that hides the menu, but only *after* the current event loop.
            //    A setTimeout with 0 delay works for this.
            setTimeout(() => {
                document.addEventListener('click', hideCustomMenu, { once: true });
            }, 0);
        });
    }

    // Function to hide the custom context menu
    function hideCustomMenu() {
        const customMenu = document.getElementById('customContextMenu');
        if (customMenu) {
            customMenu.style.display = 'none';
        }
    }




</script>