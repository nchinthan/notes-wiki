<div class="markdown prose w-full break-words dark:prose-invert dark"><p>Mutexes are achieved using atomic operations by leveraging <strong>hardware-supported atomic instructions</strong> and <strong>low-level synchronization primitives</strong>. Here's how it works in detail:</p><hr><h2><strong>1. Achieving Mutex Through Atomic Operations</strong></h2><p>A <strong>mutex</strong> (short for mutual exclusion) is a synchronization primitive that ensures only one thread can access a critical section at a time. Atomic operations provide a foundation for implementing efficient mutexes.</p><h3><strong>A. Hardware-Supported Atomic Instructions</strong></h3><p>Modern CPUs provide atomic operations such as:</p><ul><li><strong>Compare-and-Swap (CAS)</strong></li><li><strong>Test-and-Set (TAS)</strong></li><li><strong>Fetch-and-Add</strong></li><li><strong>Load-Link/Store-Conditional (LL/SC) (used in ARM, RISC-V, and POWER architectures)</strong></li></ul><p>These instructions <strong>guarantee</strong> that the read-modify-write sequence is performed <strong>without interruption</strong>, ensuring atomicity.</p><hr><h2><strong>2. How Mutex Works Without Busy Waiting</strong></h2><p>NaÃ¯ve implementations using spinlocks rely on <strong>busy waiting</strong>, where the thread continuously checks a flag in a loop. However, <strong>efficient mutexes avoid busy waiting</strong> by using <strong>blocking mechanisms</strong> provided by the OS.</p><h3><strong>A. Steps for Mutex Locking</strong></h3><ol><li><p><strong>Try Locking with an Atomic Operation</strong></p><ul><li>A thread attempts to acquire the lock using <code>CAS</code> or <code>TAS</code>.</li><li>If successful, it enters the critical section.</li><li>If unsuccessful, it <strong>sleeps</strong> instead of spinning.</li></ul></li><li><p><strong>Put the Thread to Sleep (OS Scheduling)</strong></p><ul><li>If a thread fails to acquire the lock, it calls the <strong>OS kernel</strong>, which <strong>suspends the thread</strong> (e.g., using <code>futex</code> in Linux)./li><li>The OS switches to another thread, preventing CPU wastage.</li></ul></li><li><p><strong>Wake Up the Thread When Mutex is Released</strong></p><ul><li>When the mutex is unlocked, the <strong>OS wakes up</strong> one of the waiting threads and schedules it for execution.</li></ul></li></ol><hr><h2><strong>3. How It Works at the CPU Level</strong></h2><h3><strong>A. Are Atomic Operations Handled by a Specific Core?</strong></h3><p>No, atomic operations are <strong>not assigned to a specific core</strong>. Instead:</p><ul><li>They rely on <strong>cache-coherence protocols</strong> (like MESI) and <strong>memory barriers</strong> to maintain correctness across cores.</li><li>When an atomic operation is executed, the CPU <strong>locks the memory bus</strong> or <strong>uses cache line locking</strong> to ensure exclusive access.</li></ul><h3><strong>B. How CPUs Ensure Atomicity Without Busy Waiting</strong></h3><ol><li><strong>Atomic Read-Modify-Write (Using CAS or LL/SC)</strong><ul><li>CPU ensures that no other core modifies the value during the operation.</li></ul></li><li><strong>Cache Coherence Protocols</strong><ul><li>Ensures all cores see the most recent value.</li></ul></li><li><strong>Futex (Fast Userspace Mutex) in Linux</strong><ul><li>Uses <strong>CAS in userspace</strong> for fast locking.</li><li>Calls <strong>kernel <code>futex</code> syscall</strong> only when waiting is needed.</li></ul></li></ol><hr><h2><strong>4. Example: Mutex Implementation in C Using Futex</strong></h2><p>Linux uses <code>futex</code> (Fast Userspace Mutex), which avoids busy waiting.</p><pre class="!overflow-visible"><div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950"><div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">c</div><div class="sticky top-9 md:top-[5.75rem]"><div class="absolute bottom-0 right-2 flex h-9 items-center"><div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center select-none px-4 py-1" aria-label="Copy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-xs"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Copy</button></span><span class="" data-state="closed"><button class="flex select-none items-center gap-1"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-xs"><path d="M2.5 5.5C4.3 5.2 5.2 4 5.5 2.5C5.8 4 6.7 5.2 8.5 5.5C6.7 5.8 5.8 7 5.5 8.5C5.2 7 4.3 5.8 2.5 5.5Z" fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M5.66282 16.5231L5.18413 19.3952C5.12203 19.7678 5.09098 19.9541 5.14876 20.0888C5.19933 20.2067 5.29328 20.3007 5.41118 20.3512C5.54589 20.409 5.73218 20.378 6.10476 20.3159L8.97693 19.8372C9.72813 19.712 10.1037 19.6494 10.4542 19.521C10.7652 19.407 11.0608 19.2549 11.3343 19.068C11.6425 18.8575 11.9118 18.5882 12.4503 18.0497L20 10.5C21.3807 9.11929 21.3807 6.88071 20 5.5C18.6193 4.11929 16.3807 4.11929 15 5.5L7.45026 13.0497C6.91175 13.5882 6.6425 13.8575 6.43197 14.1657C6.24513 14.4392 6.09299 14.7348 5.97903 15.0458C5.85062 15.3963 5.78802 15.7719 5.66282 16.5231Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M14.5 7L18.5 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>Edit</button></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdatomic.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/futex.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>

<span class="hljs-comment">// Simple Futex-based Mutex</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">_Atomic</span> <span class="hljs-type">int</span> lock;
} futex_mutex;

<span class="hljs-type">void</span> <span class="hljs-title function_">futex_wait</span><span class="hljs-params">(<span class="hljs-keyword">_Atomic</span> <span class="hljs-type">int</span> *futex_addr, <span class="hljs-type">int</span> expected)</span> {
    syscall(SYS_futex, futex_addr, FUTEX_WAIT, expected, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">futex_wake</span><span class="hljs-params">(<span class="hljs-keyword">_Atomic</span> <span class="hljs-type">int</span> *futex_addr)</span> {
    syscall(SYS_futex, futex_addr, FUTEX_WAKE, <span class="hljs-number">1</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">futex_lock</span><span class="hljs-params">(futex_mutex *m)</span> {
    <span class="hljs-type">int</span> expected = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!atomic_compare_exchange_weak(&amp;m-&gt;lock, &amp;expected, <span class="hljs-number">1</span>)) {
        expected = <span class="hljs-number">0</span>;
        futex_wait(&amp;m-&gt;lock, <span class="hljs-number">1</span>);
    }
}

<span class="hljs-type">void</span> <span class="hljs-title function_">futex_unlock</span><span class="hljs-params">(futex_mutex *m)</span> {
    <span class="hljs-type">atomic_store</span>(&amp;m-&gt;lock, <span class="hljs-number">0</span>);
    futex_wake(&amp;m-&gt;lock);
}

<span class="hljs-type">void</span> *<span class="hljs-title function_">thread_func</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> {
    futex_mutex *m = (futex_mutex *)arg;
    futex_lock(m);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Thread %ld acquired lock\n"</span>, pthread_self());
    sleep(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Thread %ld releasing lock\n"</span>, pthread_self());
    futex_unlock(m);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    futex_mutex m = { .lock = ATOMIC_VAR_INIT(<span class="hljs-number">0</span>) };
    <span class="hljs-type">pthread_t</span> t1, t2;

    pthread_create(&amp;t1, <span class="hljs-literal">NULL</span>, thread_func, &amp;m);
    pthread_create(&amp;t2, <span class="hljs-literal">NULL</span>, thread_func, &amp;m);

    pthread_join(t1, <span class="hljs-literal">NULL</span>);
    pthread_join(t2, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></div></div></pre><h3><strong>How This Works:</strong></h3><ol><li><strong>Try acquiring the lock with <code>CAS</code>.</strong></li><li>If unsuccessful, call <code>futex_wait()</code> to block.</li><li>When unlocking, call <code>futex_wake()</code> to wake up a waiting thread.</li></ol><hr><h2><strong>5. Summary</strong></h2><ul><li><strong>Atomic operations (CAS, LL/SC, etc.)</strong> are used for basic locking.</li><li><strong>Mutexes avoid busy waiting</strong> by using <strong>OS kernel support (e.g., <code>futex</code>)</strong>.</li><li><strong>CPU ensures atomicity via cache coherence and memory barriers</strong>.</li><li><strong>Threads are put to sleep when waiting, reducing CPU usage</strong>.</li></ul><p>Would you like a more detailed breakdown of any part? ðŸš€</p></div><div class="markdown prose w-full break-words dark:prose-invert dark"><h3><strong>What Does "Putg a Thread to Sleep" Mean?</strong></h3><p>When we say a thread is <strong>put to sleep</strong>, it means the thread <strong>stops executing and is removed from the CPU temporarily</strong> until it is woken up. The thread does not consume CPU resources during this time. Instead, it is moved to a <strong>waiting state</strong>, and the OS schedules another thread to run.</p><p>This mechanism is part of <strong>thread scheduling</strong>, managed by the <strong>OS scheduler</strong>, which handles multiple threads efficiently.</p><hr><h2><strong>How Does the OS Manage Sleeping Threads?</strong></h2><p>Yes, the OS <strong>manages a queue</strong> (or multiple queues) for different thread states.</p><h3><strong>1. Thread States in an OS</strong></h3><p>A thread can be in one of the following states:</p><ul><li><strong>Running</strong> â†’ Actively executing on a CPU core.</li><li><strong>Ready</strong> â†’ Waiting in the ready queue for CPU time.</li><li><strong>Blocked (Sleeping/Waiting)</strong> â†’ Cannot rul some condition is met (e.g., waiting for I/O or a mutex).</li><li><strong>Terminated</strong> â†’ Finished execution.</li></ul><p>When a thread <strong>sleeps</strong>, it moves from the <strong>running state</strong> to the <strong>blocked state</strong> (or a wait queue).</p><hr><h3><strong>2. Example: Mutex and Sleeping Threads</strong></h3><p>When a thread tries to acquire a mutex:</p><ul><li>If the mutex is <strong>available</strong>, the thread takes it and continues.</li><li>If the mutex is <strong>locked</strong>, the thread is put in a <strong>wait queue</strong> instead of spinning in a loop.</li></ul><p>ðŸ”¹ <strong>OS places the thread in a wait queue</strong> until the mutex is released.<br>ðŸ”¹ <strong>When the mutex is unlocked, the OS wakes up a thread</strong> from the queue.</p><p><strong>Linux Example (<code>futex</code>)</strong>:</p><ul><li>A thread trying to lock a mutex uses <strong>atomic operations</strong> to check availability.</li><li>If the mutex is locked, the thread calls the futex syscall</strong>, which moves it to the <strong>waiting queue</strong> in the kernel.</li><li>When the mutex is released, the <strong>futex syscall wakes up</strong> one of the waiting threads.</li></ul><hr><h3><strong>3. Does Sleeping Mean the Thread is Completely Stopped?</strong></h3><p>Not exactly. The thread is <strong>paused</strong>, but it is still in memory and tracked by the OS scheduler.</p><ul><li>It does <strong>not</strong> execute any instructions.</li><li>It <strong>does not consume CPU</strong> but still exists in a <strong>waiting queue</strong>.</li><li>It will <strong>wake up</strong> when a certain condition is met (e.g., timeout, mutex unlocked, or an event occurs).</li></ul><hr><h3><strong>4. Real-World Example: Thread Sleep in Code</strong></h3><h4><strong>A. Blocking with Sleep (Explicitly Pausing a Thread)</strong></h4><pre class="!overflow-visible"><div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950"><div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">c</div><div class="sticky top-9 md:top-[5.75rem]"><div class="absolute bottom-0 right-2 flex h-9 items-center"><div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center select-none px-4 py-1" aria-label="Copy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-xs"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Copy</button></span><span class="" data-state="closed"><button class="flex select-none items-center gap-1"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-xs"><path d="M2.5 5.5C4.3 5.2 5.2 4 5.5 2.5C5.8 4 6.7 5.2 8.5 5.5C6.7 5.8 5.8 7 5.5 8.5C5.2 7 4.3 5.8 2.5 5.5Z" fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M5.66282 16.5231L5.18413 19.3952C5.12203 19.7678 5.09098 19.9541 5.14876 20.0888C5.19933 20.2067 5.29328 20.3007 5.41118 20.3512C5.54589 20.409 5.73218 20.378 6.10476 20.3159L8.97693 19.8372C9.72813 19.712 10.1037 19.6494 10.4542 19.521C10.7652 19.407 11.0608 19.2549 11.3343 19.068C11.6425 18.8575 11.9118 18.5882 12.4503 18.0497L20 10.5C21.3807 9.11929 21.3807 6.88071 20 5.5C18.6193 4.11929 16.3807 4.11929 15 5.5L7.45026 13.0497C6.91175 13.5882 6.6425 13.8575 6.43197 14.1657C6.24513 14.4392 6.09299 14.7348 5.97903 15.0458C5.85062 15.3963 5.78802 15.7719 5.66282 16.5231Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M14.5 7L18.5 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>Edit</button></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> <span class="hljs-comment">// For sleep()</span></span>

<span class="hljs-type">void</span> *<span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Thread going to sleep...\n"</span>);
    sleep(<span class="hljs-number">3</span>);  <span class="hljs-comment">// Thread is put to sleep (blocked state)</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Thread woke up!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
</code></div></div></pre><ul><li>The thread <strong>sleeps</strong> for 3 seconds.</li><li>It is moved to the <strong>waiting queue</strong>.</li><li>After 3 seconds, the OS <strong>moves it back to the ready queue</strong>.</li></ul><h4><strong>B. Sleeping While Waiting for a Mutex</strong></h4><pre class="!overflow-visible"><div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950"><div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">c</div><div class="sticky top-9 md:top-[5.75rem]"><div class="absolute bottom-0 right-2 flex h-9 items-center"><div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center select-none px-4 py-1" aria-label="Copy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-xs"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Copy</button></span><span class="" data-state="closed"><button class="flex select-none items-center gap-1"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-xs"><path d="M2.5 5.5C4.3 5.2 5.2 4 5.5 2.5C5.8 4 6.7 5.2 8.5 5.5C6.7 5.8 5.8 7 5.5 8.5C5.2 7 4.3 5.8 2.5 5.5Z" fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M5.66282 16.5231L5.18413 19.3952C5.12203 19.7678 5.09098 19.9541 5.14876 20.0888C5.19933 20.2067 5.29328 20.3007 5.41118 20.3512C5.54589 20.409 5.73218 20.378 6.10476 20.3159L8.97693 19.8372C9.72813 19.712 10.1037 19.6494 10.4542 19.521C10.7652 19.407 11.0608 19.2549 11.3343 19.068C11.6425 18.8575 11.9118 18.5882 12.4503 18.0497L20 10.5C21.3807 9.11929 21.3807 6.88071 20 5.5C18.6193 4.11929 16.3807 4.11929 15 5.5L7.45026 13.0497C6.91175 13.5882 6.6425 13.8575 6.43197 14.1657C6.24513 14.4392 6.09299 14.7348 5.97903 15.0458C5.85062 15.3963 5.78802 15.7719 5.66282 16.5231Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M14.5 7L18.5 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>Edit</button></span></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-c">pthread_mutex_lock(&amp;mutex);  <span class="hljs-comment">// If locked, the thread sleeps (wait queue)</span>
critical_section();
pthread_mutex_unlock(&amp;mutex);  <span class="hljs-comment">// Wakes up a waiting thread</span>
</code></div></div></pre><ul><li>If the mutex is locked, the thread <strong>sleeps in the OS wait queue</strong>.</li><li>When another thread unlocks it, the OS <strong>wakes up one thread from the queue</strong>.</li></ul><hr><h2><strong>5. Does Each Sleeping Thread Have Its Own Queue?</strong></h2><p>Not necessarily. The OS maintains <strong>global and per-object wait queues</strong>:</p><ul><li><strong>Global Scheduler Queue</strong> â Manages all threads across the system.</li><li><strong>Wait Queues for Mutexes, I/O, and Events</strong> â†’ Each mutex, I/O device, or event may have its own queue.</li></ul><p>For example:</p><ul><li><strong>Mutex wait queue</strong> â†’ Threads waiting for a locked mutex.</li><li><strong>I/O wait queue</strong> â†’ Threads waiting for disk/network input.</li><li><strong>Timer queue</strong> â†’ Threads waiting for a timeout (e.g., <code>sleep()</code>).</li></ul><hr><h2><strong>6. Summary</strong></h2><p>âœ… <strong>Sleeping means a thread stops execution temporarily and is moved to a wait queue</strong>.<br>âœ… <strong>The OS manages sleeping threads using wait queues</strong> instead of busy waiting.<br>âœ… <strong>Threads are woken up when an event occurs</strong> (mutex unlocked, I/O done, timeout reached).<br>âœ… <strong>This avoids CPU wastage, making multitasking efficient</strong>.</p><p>Would you like a deeper explanation of OS scheduling or specific wait queues? ðŸš€</p></div>