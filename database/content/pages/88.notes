<div class="flex w-full flex-col gap-1 empty:hidden first:pt-[3px]"><div class="markdown prose w-full break-words dark:prose-invert dark"><p>Here’s a table summarizing the differences between <strong>Process</strong> and <strong>Thread</strong>:</p><table><thead><tr><th><strong>Aspect</strong></th><th><strong>Process</strong></th><th><strong>Thread</strong></th></tr></thead><tbody><tr><td><strong>Definition</strong></td><td>Independent program in execution with its own address space, resources, and memory.</td><td>Smallest unit of execution within a process. Shares memory and resources with other threads in the same process.</td></tr><tr><td><strong>Memory Allocation</strong></td><td>Each process has its own isolated memory space.</td><td>Threads within the same process share memory (e.g., heap, global variables) but each has its own <strong>stack</strong> and <strong>registers</strong>.</td></tr><tr><td><strong>Overhead</strong></td><td>Higher overhead due to isolated memory and resources.</td><td>Lower ovhead as threads share memory and resources within the same process.</td></tr><tr><td><strong>Execution</strong></td><td>Processes run independently. If one process fails, others are unaffected.</td><td>Threads within a process are dependent. A failure in one thread can cause the entire process to fail.</td></tr><tr><td><strong>Communication</strong></td><td>Communication between processes is complex and resource-intensive (via IPC mechanisms like pipes, message queues).</td><td>Threads can easily communicate since they share the same memory space.</td></tr><tr><td><strong>Creation and Termination</strong></td><td>Creating and managing processes requires more resources and takes more time.</td><td>Threads are lighter and faster to create/terminate.</td></tr><tr><td><strong>Concurrency</strong></td><td>Processes can run concurrently on multiple cores.</td><td>Threads within a process can run concurrently on multiple cores, leveraging parallelism.</td></tr><tr><td><strong>Failure Impact</strong></td><td>Process failure does not affect other processes due to memory isolation.</td><td>Failure in one thread can affect the entire process because threads share the same memory space.</td></tr><tr><td><strong>Execution Context</strong></td><td>Each process has its own set of registers, memory, and execution state.</td><td>Each thread has its own <strong>stack</strong> and <strong>set of registers</strong> (e.g., program counter, stack pointer), but shares the <strong>heap</strong> with other threads in the same process.</td></tr></tbody></table><p>This table highlights the core differences in terms of isolation, resource management, execution behavior, and memory usage between processes and threads.</p></div></div><div class="flex w-full flex-col gap-1 empty:hidden first:pt-[3px]"><div class="markdown prose w-full break-words dark:prose-invert dark"><h3><strong>Context Switching</strong></h3><p><strong>Context switching</strong> is the process of storing and restoring the state (context) of a CPU so that multiple processes or threads can share a single CPU core. It is essential for multitasking in modern operating systems, allowing the system to switch between different processes or threads efficiently.</p><ul><li><p><strong>Context</strong> refers to the CPU registers, program counter (PC), stack pointer (SP), and other states necessary to resume the execution of a task. When a context switch occurs, the operating system saves the context of the currently running process or thread and loads the context of the next task to be executed.</p></li><li><p><strong>Process Context Switching</strong> involves saving the state of a process, including its memory map, CPU registers, and other resources it uses. When switching from one process to another, the operating system must perform additional steps like updating memory mappings, ensuring isolation, and handling process states (e.g., ready, running, waiting).</p></li><li><p><strong>Thread Context Switching</strong> is less expensive compared to process context switching because threads share the same memory space. When switching between threads, only the <strong>CPU registers</strong> and the <strong>stack</strong> (specific to the thread) need to be saved and restored. The <strong>memory</strong> and <strong>resources</strong> of the process are not switched, making the operation quicker and less resource-intensive.</p></li></ul><h3><strong>Why Process Switching is More Expensive than Thread Switching</strong></h3><ol><li><p><strong>Memory and Resource Isolation</strong>:</p><ul><li><strong>Processes</strong> have their own memory space, file descriptors, and system resources. When switching between processes, the operating system must save and restore the <strong>entire memory map</strong>, including the memory regions, page tables, and open files.</li><li><strong>Threads</strong>, on the other hand, share the same memory space and resources within the process. Therefore, when switching between threads, the operating system only needs to save and restore the <strong>CPU registers</strong> and the <strong>thread’s stack</strong>.</li></ul></li><li><p><strong>Larger Overhead</strong>:</p><ul><li><strong>Process Switching</strong> requires more steps due to the isolation between processes. The operating system must perform additional work like saving the process's memory state, handling process control blocks (PCB), and updating the page tables.</li><li><strong>Thread Switching</strong> is less costly because threads within the same process share the same resources and memory, so the operating system only needs to manage the <strong>thread's local state</strong> (e.g., CPU registers, program counter, stack pointer).</li></ul></li><li><p><strong>Time and Complexity</strong>:</p><ul><li><strong>Process Context Switching</strong> involves more time and complexity due to the need to switch memory mappings, protection settings, and resources. The switch between processes also involves updating the process scheduler and handling the potential suspension and resumption of processes in different stes.</li><li><strong>Thread Context Switching</strong> is faster and simpler, as it only involves saving the state of the thread (such as the stack and registers) without affecting the memory or resources shared by the threads in the same process.</li></ul></li></ol><h3><strong>Summary:</strong></h3><ul><li><strong>Context switching</strong> allows multiple tasks to run on a CPU by saving and restoring their execution contexts.</li><li><strong>Process context switching</strong> is more expensive because it involves switching memory spaces, resources, and system states.</li><li><strong>Thread context switching</strong> is less expensive because threads share memory and resources, and only the execution state of the thread itself needs to be saved and restored.</li></ul></div></div><iframe width="420" height="345" src="https://www.youtube.com/watch?v=4rLW7zg21gI"></iframe>