<div class="markdown prose w-full break-words dark:prose-invert dark"><h3 data-start="0" data-end="66" class=""><strong data-start="4" data-end="64">Notes on Factor Analysis &amp; Variational Autoencoder (VAE)</strong></h3>
<h4 data-start="68" data-end="120" class=""><strong data-start="73" data-end="118">Factor Analysis (FA) - Brief Introduction</strong></h4>
<p data-start="121" data-end="344" class="">Factor Analysis is a <strong data-start="142" data-end="180">dimensionality reduction technique</strong> that assumes observed data <strong data-start="208" data-end="213">X</strong> can be represented as a linear combination of a few <strong data-start="266" data-end="284">latent factors</strong> (<strong data-start="286" data-end="291">Z</strong>) plus some <strong data-start="303" data-end="312">noise</strong>. The model can be written as:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><mi>W</mi><mi>Z</mi><mo>+</mo><mi>Î¼</mi><mo>+</mo><mi>Ïµ</mi></mrow><annotation encoding="application/x-tex">X = WZ + \mu + \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.07847em;">X</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mord mathnormal" style="margin-right: 0.07153em;">Z</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.1944em;"></span><span ass="mord mathnormal">Î¼</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">Ïµ</span></span></span></span></span>
<p data-start="375" data-end="383" class="">where:</p>
<ul data-start="384" data-end="571">
<li data-start="384" data-end="454" class="" style="">
<p data-start="386" data-end="454" class=""><strong data-start="386" data-end="391">Z</strong>: Latent variables (lower-dimensional representation of data)</p>
</li>
<li data-start="455" data-end="505" class="" style="">
<p data-start="457" data-end="505" class=""><strong data-start="457" data-end="462">W</strong>: Transformation matrix (factor loadings)</p>
</li>
<li data-start="506" data-end="534" class="" style="">
<p data-start="508" data-end="534" class=""><strong data-start="508" data-end="513">Î¼</strong>: Mean shift (bias)</p>
</li>
<li d-start="535" data-end="571" class="" style="">
<p data-start="537" data-end="571" class=""><strong data-start="537" data-end="542">Î¨</strong>: Covariance of noise <strong data-start="564" data-end="569">Îµ</strong></p>
</li>
</ul>
<p data-start="573" data-end="720" class="">FA can be used to <strong data-start="591" data-end="621">discover hidden structures</strong> in data and <strong data-start="634" data-end="668">generate realistic new samples</strong> by sampling from the learned latent distribution.</p>
<hr data-start="722" data-end="725" class="" style="">
<h2 data-start="727" data-end="763" class=""><strong data-start="730" data-end="763">Variational Autoencoder (VAE)</strong></h2>
<p data-start="764" data-end="920" class="">VAE is an extension of FA but with <strong data-start="799" data-end="816">deep learning</strong>. It learns to represent data in a <strong data-start="851" data-end="878">continuous latent space</strong> and generate new samples from this space.</p>
<h3 data-start="922" data-end946" class=""><strong data-start="926" data-end="944">Encoder in VAE</strong></h3>
<p data-start="947" data-end="1119" class="">The encoderâ€™s job is to learn the distribution of the <strong data-start="1001" data-end="1020">latent vector Z</strong> given the input <strong data-start="1037" data-end="1042">X</strong>. Instead of learning a single value for <strong data-start="1083" data-end="1088">Z</strong>, it <strong data-start="1093" data-end="1118">models a distribution</strong>:</p>
<span class="katex-display" style=""><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>z</mi><mi mathvariant="normal">âˆ£</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mi>z</mi><mi mathvariant="normal">âˆ£</mi><mi>Î¼</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">Î£</mi><chy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(z|x) = \mathcal{N}(z | \mu(x), \Sigma(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.03588em;">q</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.04398em;">z</span><span class="mord">âˆ£</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.14736em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.04398em;">z</sp><span class="mord">âˆ£</span><span class="mord mathnormal">Î¼</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">Î£</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span></span>
<ul data-start="1170" data-end="1439">
<li data-start="1170" data-end="1230" class="" style="">
<p data-start="1172" data-end="1230" class="">It predicts <strong data-start="1184" data-end="1196">Î¼ (mean)</strong> and <strong data-start="1201" data-end="1217">Î£ (variance)</strong> for <strong data-start="1222" data-end="1227">Z</strong>.</p>
</li>
<li data-start="1231" data-end="1369" class="" style="">
<p data-start="1233" data-end="1286" class="">Instead of directly assigning <strong data-start="1263" data-end="1268">Z</strong>, we sample using:</p>
<span class="katex-display" style=""><span class="katex"><lass="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>z</mi><mo>=</mo><mi>Î¼</mi><mo>+</mo><mi>Ïƒ</mi><mo>â‹…</mo><mi>Ïµ</mi><mo separator="true">,</mo><mspace width="1em"></mspace><mi>Ïµ</mi><mo>âˆ¼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">z = \mu + \sigma \cdot \epsilon, \quad \epsilon \sim \mathcal{N}(0, I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.04398em;">z</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">Î¼</span>ss="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal" style="margin-right: 0.03588em;">Ïƒ</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">â‹…</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">Ïµ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">Ïµ</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">âˆ¼</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span classmathcal" style="margin-right: 0.14736em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.07847em;">I</span><span class="mclose">)</span></span></span></span></span>
</li>
<li data-start="1370" data-end="1439" class="" style="">
<p data-start="1372" data-end="1439" class="">This is the <strong data-start="1384" data-end="1412">reparameterization trick</strong>, allowing backpropagation.</p>
</li>
</ul>
<p data-start="1441" data-end="1514" class="">Thus, <strong data-start="1447" data-end="1513">the encoder is trying to figure out the proper Z for a given X</strong>.</p>
<hr data-start="1516" data-end="1519" class="" style="">
<h3 data-start="1521" data-end="1545" class=""><strong data-start="1525" data-end="1543">Decoder in VAE</strong></h3>
<p data-start="1546" data-end="1614" class="">Once <strong data-start="1551" data-end="1556">Z</strong> is found, the decoderâ€™s job is to find <strong data-start="1596" data-end="1601">W</strong> such that:</p>
<span class="katex-display" style=""><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>W</mi><mi>Z</mi><mo>+</mo><mi>Î¼</mi></mrow><annotation encoding="application/x-tex">Y = WZ + \mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">Y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mord mathnormal" style="margin-right: 0.07153em;">Z</span><span class="mspacstyle="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">Î¼</span></span></span></span></span>
<p data-start="1634" data-end="1686" class="">where <strong data-start="1640" data-end="1645">Y</strong> is the reconstructed version of <strong data-start="1678" data-end="1683">X</strong>.</p>
<ul data-start="1687" data-end="1886">
<li data-start="1687" data-end="1739" class="" style="">
<p data-start="1689" data-end="1739" class=""><strong data-start="1689" data-end="1709">Decoder learns W</strong>, the transformation matrix.</p>
</li>
<li data-start="1740" data-end="1814" class="" style="">
<p data-start="1742" data-end="1814" class="">It tries to generate a <strong data-start="1765" data-end="1793">realistic reconstruction</strong> of <strong data-start="1797" data-end="1802">X</strong> from <strong data-start=1808" data-end="1813">Z</strong>.</p>
</li>
<li data-start="1815" data-end="1886" class="" style="">
<p data-start="1817" data-end="1886" class="">The reconstruction noise follows <strong data-start="1850" data-end="1855">Î¨</strong>, a diagonal covariance matrix.</p>
</li>
</ul>
<p data-start="1888" data-end="2000" class="">Thus, <strong data-start="1894" data-end="1978">the decoder is trying to find W such that WZ + Î¼ gives a near-realistic output Y</strong>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.07847em;">X</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-r0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">Y</span></span></span></span>.</p>
<hr data-start="2002" data-end="2005" class="" style="">
<h3 data-start="2007" data-end="2030" class=""><strong data-start="2011" data-end="2030">Why This Works?</strong></h3>
<ul data-start="2031" data-end="2317">
<li data-start="2031" data-end="2113" class="" style="">
<p data-start="2033" data-end="2113" class="">The encoder ensures <strong data-start="2053" data-end="2110">similar inputs have nearby representations in Z-space</strong>.</p>
</li>
<li data-start="2114" data-end="2183" class="" style="">
<p data-start="2116" data-end="2183" class="">The decoder ensures the reconstructed <strong data-start="2154" data-end="2180">Y resembles the real X</strong>.</p>
</li>
<li data-start="2184" data-end="2317" class="" style="">
<p data-start="2186" data-end="2317" class="">Since <strong data-start="2192" data-end="2231">Z follows a structured distribution</strong>, new samples can be <strong data-start="2252" data-end="2265">generated</strong> by sampling a new <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>âˆ¼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">z \sim \mathcal{N}(0, I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.04398em;">z</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">âˆ¼</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathcal" style="margin-right: 0.14736em;">N</spspan class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.07847em;">I</span><span class="mclose">)</span></span></span></span>.</p>
</li>
</ul>
<p data-start="2319" data-end="2412" class="">This allows VAE to not only <strong data-start="2347" data-end="2364">compress data</strong> but also <strong data-start="2374" data-end="2408">generate new realistic samples</strong>! ðŸš€</p></div>