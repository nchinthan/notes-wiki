
<p class="pageTitle"><span style="color: var(--bs-heading-color,inherit); font-size: 2rem; font-family: var(--bs-body-font-family); text-align: var(--bs-body-text-align);">Avoiding race conditions</span></p>

<ul>
<li><p>It's difficult to find a correct solution to the <a href="http://www.stolaf.edu/people/rab/OS/S18/racecond.html">dining
philosophers</a> problem.  How can we avoid 
starvation, deadlock, and race conditions?   Can we find an algorithm
that is fair (all philosophers get comparable opportunities to eat),
has a high degree of concurrency (e.g., allows multiple
philosophers to eat at the same time), and does not require
philosophers to wait long to eat when they're ready?  Will a solution
remain feasible for a very large number of processors?</p></li>

<li><p>Deadlock and starvation are very bad, but nothing compares to
debugging race conditions:  if the correct behavior of an algorithm
depends on 
timing (definition of race condition), then incorrect behavior can't
be reproduced, because we can't expect exact duplication of a sporadic
sequence of events.  </p></li>

<li><p>Fortunately, the cause of race conditions is known:
<em>between checking on a critical resource and acting on that check,
another process intervenes, making that check out of date and the
action incorrect.</em>  For example, in the first <a href="http://www.stolaf.edu/people/rab/OS/S18/racecond2.html#dp3">race condition example</a> for the
dining philosophers problem, a race occurs during the <code>if</code>
statement 
</p><pre>   if (!myturn[p])
      sleep()    /* to be awakened by prev philosopher */
</pre>
If another process <em>B</em> changes <code>myturn[p]</code> to true
<em>after</em> this process <em>A</em> evaluates the guard
<code>(!myturn[p]</code> and <em>before</em> process <em>A</em> calls
<code>sleep()</code>, then <em>B</em>'s <code>wakeup()</code> call may
be wasted before <em>A</em> has called <code>sleep()</code>, meaning
that there will be no way to wake up <em>A</em>.  Here, the guard 
<code>(!myturn[p]</code> is the "check" and the <code>sleep()</code>
call is the action that should only be perfomed if
<code>myturn[p]</code> is false.
<p></p></li>

<li><p>Therefore, to avoid race conditions, we must somehow guarantee
that no process <em>B</em> can intervene during process <em>A</em>'s
evaluation of conditionals that involve shared computing resources.  That would
make for an <em>atomic</em> (or <em>indivisible</em>) <code>if</code>
statement. 
</p></li>

<li><p>One way to make operations indivisible is to locate them in a
separate <em>synchronization process</em> that receives requests and
sends responses through message passing.  If all processes use the
synchronization process to access the shared resources, then the
synchronization process can guarantee that no two processes interfere
with each other to cause a race.</p></li>

<li><p>There are other strategies for implementing atomicity for
correct <em>interprocess communication</em> besides message-passing
approaches.  But message passing fits parallel computing well,
especially in distributed computing environments (many of the other
solutions depend on all processes being on one computer and one
operating system).</p></li>

<li><p>______</p></li>

</ul>

<p>In the solutions to the Dining Philosophers problem below, we will
assume that race conditions are avoided using some kind of atomicity
strategy.</p>

<h2>The waiter solution to Dining Philosophers</h2>

<ul>
<li><p>The <strong>waiter solution</strong> provides a simple way to
solve the Dining Philosophers problem, assuming an external entity
called the <em>waiter</em>.</p></li>

<li><p>Strategy:</p>
<ul>
<li><p>Every philosopher must request each of their (shared)
chopsticks from a waiter, who may refuse the request at first in order
to avoid a deadlock. </p></li>

<li><p>For convenience, we assume that all philosophers request their
left chopstick first, then their right chopstick.   </p></li>

<li><p>The waiter always provides chopsticks upon request
<em>unless</em> only one chopstick remains unused.  In that case, the
waiter honors the request only if a <em>right</em> chopstick is
requested;  requests for a left chopstick are <em>deferred</em> until
another philosopher finishes eating.  </p></li>

</ul>
</li>

<li><p>Argument for correct <em>deadlock avoidance</em>:  The last
chopstick will only be assigned if the waiter is certain that at least
one philosopher can finish eating (thereupon releasing chopsticks).
Therefore, the "circular wait" required for deadlock can't occur.</p></li>

<li><p>No starvation; fairness (depending on your waiter); degree of
concurrency...</p></li> 

<li><p>Downside: Scalability (the waiter could become a bottleneck if
the number of processors is large).  </p></li><li><p>the assignment of chopsticks is linear i.e only one chopstick can be assigned at a time.</p></li>

</ul>


<h2>Chandy-Misra solution</h2>

<ul>
<li><p>In 1984, K. Chandy and J. Misra proposed a solution to a
generalized Dining Philosophers problem, which doesn't require the
philosophers to be in a circle or to share only two resources with
only nearest neighbors.</p></li>

<li><p>Chandy-Misra's algorithm may be described in terms of "clean"
and "dirty" chopsticks.  Each chopstick is shared with a pair of
philosophers.  </p> 
<ul>
<li><p>Each chopstick is always <em>in the possession</em> of one of it's two
philosophers.  </p><p>Also, a dirty chopstick is <em>always cleaned just
before it is given</em> to its other philosopher.</p></li>

<li><p><em>Initialization.</em>  Every process receives a unique
integer ID number.  For every pair of philosophers who contend for a
chopstick, one chopstick is created,  assigned to the philosopher
with the <em>lower</em> ID number (lower neighbor), and marked as
"dirty."</p></li>  
<li><p><em>Thinking.</em>  When a philosopher <em>p</em> is thinking,
if that philosopher <em>p</em> receives a 
request for a particular chopstick <em>c</em> from one of that philosopher's
neighbors,  then <em>p</em> gives the neighbor that chopstick
<em>c</em> (after cleaning it). </p></li>

<li><p><em>Hungry.</em>  When a philosopher <em>p</em>
is preparing to eat, <em>p</em> requests any chopsticks that <em>p</em> doesn't
already have from the appropriate neighbor.  </p>
<p>During this
time, if a neighbor asks <em>p</em> for a chopstick that <em>p</em>
possesses, then <em>p</em> <em>sends that chopstick</em> (after cleaning it) if
it's dirty, and <em>keeps</em> that chopstick for the
present if it's clean.  <em>p</em>
<em>defers</em> the requests for already-clean chopsticks (i.e.,
remembers the clean requests for later delivery).</p></li> 

<li><p><em>Eating.</em>  A philosopher <em>p</em> may start eating as
soon as <em>p</em> has all of <em>p</em>'s chopsticks.  While eating,
all requests for chopsticks are deferred, and all chopsticks become
dirty.</p></li> 

<li><p><em>Cleanup.</em>  Immediately after eating, a philosopher
delivers any chopsticks for which there are deferred requests (after cleaning
them).  That philosopher then proceeds to eat.</p></li>


</ul>

</li>

<li><p><em>Deadlock avoidance</em> of the Chandy-Misra algorithm can
be proven using directed graphs:  each philosopher represents a
vertex, and each edge represents a chopstick, with an arrow going from
"dirty towards clean".  The ID ordering of philosophers can be used to
show that this graph never has a closed cycles (i.e., deadlock
circular waits), by reassigning a (lower) ID to philosophers just
after they finish eating, thus insuring that the graph's arrows always
point from lower towards higher IDs.  </p></li>

<li><p><em>No starvation:</em>  Since a hungry philosopher <em>p</em> always
keeps <em>p</em>'s clean chopsticks, and since each of <em>p</em>'s neighbors
must deliver their shared chopstick to <em>p</em>, cleaned, either
immediately (if the neighbor is thinking) or as soon as
that neighbor finishes eating, then we conclude that a hungry
philosopher <em>p</em> cannot be passed up more than once by any
neighbor.  By transitivity, each of <em>p</em>'s hungry or eating
neighbors must eventually finish eating, which guarantees that
<em>p</em> won't starve.  (But <em>p</em> may have to fast for a long time.)
</p></li> 

<li><p>Fairness (after eating, all resources are designated for the
neighbors);  high degree of concurrency; scalable (because after
initialization; the resource management is local -- no central
authority needed);  generalizes to any number of processes and
resources (as long as each resource is shared by exactly two
processes). </p></li>

<li><p>Downside:  potentially long wait chains when hungry.</p></li>

</ul>


<p class="footer"><br></p>


