{
    "title": "paging in memory",
    "html": "<div class=\"markdown prose w-full break-words dark:prose-invert dark\"><h3 data-start=\"0\" data-end=\"48\"><strong data-start=\"4\" data-end=\"46\">Summary of Paging in Memory Management</strong></h3><h4 data-start=\"50\" data-end=\"84\"><strong data-start=\"55\" data-end=\"82\">Basic Concept of Paging</strong></h4><p data-start=\"85\" data-end=\"215\">Paging is a memory management technique that divides both <strong data-start=\"143\" data-end=\"161\">virtual memory</strong> and <strong data-start=\"166\" data-end=\"191\">physical memory (RAM)</strong> into fixed-size blocks:</p><ul data-start=\"216\" data-end=\"423\"><li data-start=\"216\" data-end=\"295\"><strong data-start=\"218\" data-end=\"227\">Pages</strong>: Fixed-size blocks in <strong data-start=\"250\" data-end=\"268\">virtual memory</strong> (logical address space).</li><li data-start=\"296\" data-end=\"359\"><strong data-start=\"298\" data-end=\"308\">Frames</strong>: Fixed-size blocks in <strong data-start=\"331\" data-end=\"350\">physical memory</strong> (RAM).</li><li data-start=\"360\" data-end=\"423\"><strong data-start=\"362\" data-end=\"376\">Page Table</strong>: A data structure that maps pages to frames.</li></ul><h4 data-start=\"425\" data-end=\"449\"><strong data-start=\"430\" data-end=\"447\">Example Setup</strong></h4><p data-start=\"450\" data-end=\"517\">If total memory = <strong data-start=\"468\" data-end=\"476\">4 KB</strong>, and each <strong data-start=\"487\" data-end=\"508\">frame size = 1 KB</strong>, then:</p><ul data-start=\"518\" data-end=\"746\"><li data-start=\"518\" data-end=\"562\">The memory has <strong data-start=\"535\" data-end=\"547\">4 frames</strong> (1 KB each).</li><li data-start=\"563\" data-end=\"622\">A <strong data-start=\"567\" data-end=\"580\">page size</strong> is also <strong data-start=\"589\" data-end=\"597\">1 KB</strong> (matching frame size).</li><li data-start=\"623\" data-end=\"746\">Each <strong data-start=\"630\" data-end=\"676\">page is stored contiguously within a frame</strong>, but different pages of the same process <strong data-start=\"718\" data-end=\"738\">may be scattered</strong> in RAM.</li></ul><hr data-start=\"748\" data-end=\"751\"><h3 data-start=\"753\" data-end=\"783\"><strong data-start=\"757\" data-end=\"781\">Advantages of Paging</strong></h3><p data-start=\"784\" data-end=\"1329\">âœ… <strong data-start=\"786\" data-end=\"823\">Eliminates External Fragmentation</strong> â€“ Since pages are fixed-size, free memory can be efficiently utilized.<br data-start=\"894\" data-end=\"897\">âœ… <strong data-start=\"899\" data-end=\"931\">Efficient Memory Utilization</strong> â€“ Non-contiguous memory allocation allows better usage of available RAM.<br data-start=\"1004\" data-end=\"1007\">âœ… <strong data-start=\"1009\" data-end=\"1036\">Supports Virtual Memory</strong> â€“ Enables running processes larger than physical memory by swapping pages in/out from secondary storage.<br data-start=\"1141\" data-end=\"1144\">âœ… <strong data-start=\"1146\" data-end=\"1171\">Fast Process Swapping</strong> â€“ Only required pages need to be moved, reducing overhead.<br data-start=\"1230\" data-end=\"1233\">âœ… <strong data-start=\"1235\" data-end=\"1267\">Process Isolation &amp; Security</strong> â€“ Ensures a process cannot access another processâ€™s memory.</p><hr data-start=\"1331\" data-end=\"1334\"><h3 data-start=\"1336\" data-end=\"1369\"><strong data-start=\"1340\" data-end=\"1367\">Disadvantages of Paging</strong></h3><p data-start=\"1370\" data-end=\"1960\">âŒ <strong data-start=\"1372\" data-end=\"1398\">Internal Fragmentation</strong> â€“ If a process doesnâ€™t fully use a page, unused space in the last page is wasted.<br data-start=\"1480\" data-end=\"1483\">âŒ <strong data-start=\"1485\" data-end=\"1507\">Increased Overhead</strong> â€“ Page tables require additional memory to store mappings.<br data-start=\"1566\" data-end=\"1569\">âŒ <strong data-start=\"1571\" data-end=\"1595\">Slower Memory Access</strong> â€“ Address translation (logical â†’ physical) adds delay. TLB (Translation Lookaside Buffer) is used to speed this up.<br data-start=\"1711\" data-end=\"1714\">âŒ <strong data-start=\"1716\" data-end=\"1739\">Page Fault Overhead</strong> â€“ If a page is missing from RAM, fetching it from disk (swap) slows down execution.<br data-start=\"1823\" data-end=\"1826\">âŒ <strong data-start=\"1828\" data-end=\"1857\">Implementation Complexity</strong> â€“ Requires additional hardware like <strong data-start=\"1894\" data-end=\"1926\">MMU (Memory Management Unit)</strong> to handle address translations.</p><hr data-start=\"1962\" data-end=\"1965\"><h3 data-start=\"1967\" data-end=\"2015\"><strong data-start=\"1971\" data-end=\"2013\">Is Paging a Solution to Fragmentation?</strong></h3><ul data-start=\"2016\" data-end=\"2254\"><li data-start=\"2016\" data-end=\"2146\"><strong data-start=\"2018\" data-end=\"2053\">âœ… Solves External Fragmentation</strong>: Since memory is allocated in fixed-size frames, processes donâ€™t require contiguous space.</li><li data-start=\"2147\" data-end=\"2254\"><strong data-start=\"2149\" data-end=\"2184\">âŒ Causes Internal Fragmentation</strong>: If a process doesnâ€™t fully utilize a page, unused space is wasted.</li></ul><p data-start=\"2256\" data-end=\"2388\">Paging allows <strong data-start=\"2270\" data-end=\"2299\">better memory utilization</strong> but comes at a cost of <strong data-start=\"2323\" data-end=\"2352\">extra page table overhead</strong> and <strong data-start=\"2357\" data-end=\"2387\">slower address translation</strong>.</p><p data-start=\"2390\" data-end=\"2462\" data-is-last-node=\"\" data-is-only-node=\"\">Would you like an example of how address translation works in paging? ğŸš€</p></div><div class=\"markdown prose w-full break-words dark:prose-invert dark\"><p data-start=\"0\" data-end=\"193\">Yes, <strong data-start=\"5\" data-end=\"31\">internal fragmentation</strong> is one of the reasons why arrays and other data structures are often sized as powers of 2 (e.g., 64, 128, 256, etc.), but it's not the only reason. Hereâ€™s why:</p><h3 data-start=\"195\" data-end=\"241\"><strong data-start=\"199\" data-end=\"239\">1. Minimizing Internal Fragmentation</strong></h3><ul data-start=\"242\" data-end=\"595\"><li data-start=\"242\" data-end=\"372\">Paging works with fixed-size <strong data-start=\"273\" data-end=\"283\">frames</strong> (e.g., 4 KB, 8 KB), and data structures that align with these sizes reduce wasted space.</li><li data-start=\"373\" data-end=\"489\">If an array size is not a power of 2, it may leave <strong data-start=\"426\" data-end=\"442\">unused space</strong> in a page, causing <strong data-start=\"462\" data-end=\"488\">internal fragmentation</strong>.</li><li data-start=\"490\" data-end=\"595\">Choosing power-of-2 sizes ensures better memory alignment with <strong data-start=\"555\" data-end=\"570\">cache lines</strong> and <strong data-start=\"575\" data-end=\"594\">page boundaries</strong>.</li></ul><h3 data-start=\"597\" data-end=\"643\"><strong data-start=\"601\" data-end=\"641\">2. Memory Alignment &amp; CPU Efficiency</strong></h3><ul data-start=\"644\" data-end=\"991\"><li data-start=\"644\" data-end=\"759\">Many CPUs and memory architectures <strong data-start=\"681\" data-end=\"690\">fetch</strong> data in chunks that are <strong data-start=\"715\" data-end=\"730\">powers of 2</strong> (e.g., 64-byte cache lines).</li><li data-start=\"760\" data-end=\"880\">If data structures are not aligned properly, the CPU may need <strong data-start=\"824\" data-end=\"840\">extra cycles</strong> to fetch data across memory boundaries.</li><li data-start=\"881\" data-end=\"991\">Using <strong data-start=\"889\" data-end=\"909\">power-of-2 sizes</strong> aligns them efficiently, reducing <strong data-start=\"944\" data-end=\"960\">cache misses</strong> and improving <strong data-start=\"975\" data-end=\"990\">performance</strong>.</li></ul><h3 data-start=\"993\" data-end=\"1031\"><strong data-start=\"997\" data-end=\"1029\">3. Fast Bitwise Computations</strong></h3><ul data-start=\"1032\" data-end=\"1347\"><li data-start=\"1032\" data-end=\"1347\">Operations like <strong data-start=\"1050\" data-end=\"1062\">indexing</strong> and <strong data-start=\"1067\" data-end=\"1088\">modulo operations</strong> are faster with powers of 2.<ul data-start=\"1122\" data-end=\"1347\"><li data-start=\"1122\" data-end=\"1272\">Instead of using <code data-start=\"1141\" data-end=\"1144\">%</code>, which is slow, we can use <strong data-start=\"1172\" data-end=\"1187\">bitwise AND</strong>:<pre class=\"!overflow-visible\" data-start=\"1193\" data-end=\"1272\"><div class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\"><div class=\"flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-[5px] h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none\">cpp</div><div class=\"sticky top-9 md:top-[5.75rem]\"><div class=\"absolute bottom-0 right-2 flex h-9 items-center\"><div class=\"flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary\"><span class=\"\" data-state=\"closed\"><button class=\"flex gap-1 items-center select-none px-4 py-1\" aria-label=\"Copy\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"icon-xs\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z\" fill=\"currentColor\"></path></svg>Copy</button></span><span class=\"\" data-state=\"closed\"><button class=\"flex select-none items-center gap-1\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"icon-xs\"><path d=\"M2.5 5.5C4.3 5.2 5.2 4 5.5 2.5C5.8 4 6.7 5.2 8.5 5.5C6.7 5.8 5.8 7 5.5 8.5C5.2 7 4.3 5.8 2.5 5.5Z\" fill=\"currentColor\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path><path d=\"M5.66282 16.5231L5.18413 19.3952C5.12203 19.7678 5.09098 19.9541 5.14876 20.0888C5.19933 20.2067 5.29328 20.3007 5.41118 20.3512C5.54589 20.409 5.73218 20.378 6.10476 20.3159L8.97693 19.8372C9.72813 19.712 10.1037 19.6494 10.4542 19.521C10.7652 19.407 11.0608 19.2549 11.3343 19.068C11.6425 18.8575 11.9118 18.5882 12.4503 18.0497L20 10.5C21.3807 9.11929 21.3807 6.88071 20 5.5C18.6193 4.11929 16.3807 4.11929 15 5.5L7.45026 13.0497C6.91175 13.5882 6.6425 13.8575 6.43197 14.1657C6.24513 14.4392 6.09299 14.7348 5.97903 15.0458C5.85062 15.3963 5.78802 15.7719 5.66282 16.5231Z\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path><path d=\"M14.5 7L18.5 11\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></svg>Edit</button></span></div></div></div><div class=\"overflow-y-auto p-4\" dir=\"ltr\"><code class=\"!whitespace-pre language-cpp\"><span>index % <span class=\"hljs-number\">64</span>  â†’  index &amp; (<span class=\"hljs-number\">64</span> - <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">// Faster bitwise operation</span>\n</span></code></div></div></pre></li><li data-start=\"1275\" data-end=\"1347\">This is common in <strong data-start=\"1295\" data-end=\"1346\">hash tables, circular buffers, and memory pools</strong>.</li></ul></li></ul><h3 data-start=\"1349\" data-end=\"1396\"><strong data-start=\"1353\" data-end=\"1394\">4. Virtual Memory &amp; Paging Efficiency</strong></h3><ul data-start=\"1397\" data-end=\"1596\"><li data-start=\"1397\" data-end=\"1471\">OS memory pages are usually <strong data-start=\"1427\" data-end=\"1442\">powers of 2</strong> (e.g., 4 KB, 8 KB, 16 KB).</li><li data-start=\"1472\" data-end=\"1596\">Allocating memory in similar <strong data-start=\"1503\" data-end=\"1517\">power-of-2</strong> sizes ensures fewer <strong data-start=\"1538\" data-end=\"1555\">wasted frames</strong> and avoids <strong data-start=\"1567\" data-end=\"1595\">extra page table entries</strong>.</li></ul><hr data-start=\"1598\" data-end=\"1601\"><h3 data-start=\"1603\" data-end=\"1620\"><strong data-start=\"1607\" data-end=\"1618\">Summary</strong></h3><p data-start=\"1621\" data-end=\"2020\">ğŸ”¹ <strong data-start=\"1624\" data-end=\"1650\">Internal Fragmentation</strong> â€“ Choosing <strong data-start=\"1662\" data-end=\"1682\">power-of-2 sizes</strong> aligns better with memory pages, reducing waste.<br data-start=\"1731\" data-end=\"1734\">ğŸ”¹ <strong data-start=\"1737\" data-end=\"1757\">Cache Efficiency</strong> â€“ Powers of 2 align with <strong data-start=\"1783\" data-end=\"1802\">CPU cache lines</strong>, reducing cache misses.<br data-start=\"1826\" data-end=\"1829\">ğŸ”¹ <strong data-start=\"1832\" data-end=\"1853\">Faster Arithmetic</strong> â€“ Power-of-2 sizes enable <strong data-start=\"1880\" data-end=\"1912\">efficient bitwise operations</strong>.<br data-start=\"1913\" data-end=\"1916\">ğŸ”¹ <strong data-start=\"1919\" data-end=\"1942\">Paging Optimization</strong> â€“ Matches the OS <strong data-start=\"1960\" data-end=\"1977\" data-is-only-node=\"\">paging system</strong>, avoiding inefficient memory allocation.</p><p data-start=\"2022\" data-end=\"2123\" data-is-last-node=\"\" data-is-only-node=\"\">Would you like an example of how power-of-2 memory alignment works in low-level memory management? ğŸš€</p></div><div class=\"markdown prose w-full break-words dark:prose-invert dark\"><h3 data-start=\"0\" data-end=\"69\"><strong data-start=\"4\" data-end=\"67\">1. Is the Page Table Managed by the OS? Where Is It Stored?</strong></h3><p data-start=\"70\" data-end=\"257\">Yes, the <strong data-start=\"79\" data-end=\"114\">page table is managed by the OS</strong>, but the <strong data-start=\"124\" data-end=\"170\">CPU hardware (Memory Management Unit, MMU)</strong> assists in translating virtual addresses to physical addresses using the page table.</p><p data-start=\"259\" data-end=\"299\">ğŸ”¹ <strong data-start=\"262\" data-end=\"297\">Where Is the Page Table Stored?</strong></p><ul data-start=\"300\" data-end=\"643\"><li data-start=\"300\" data-end=\"396\"><strong data-start=\"302\" data-end=\"349\">Page tables are stored in RAM (main memory)</strong> because they need to be accessed frequently.</li><li data-start=\"397\" data-end=\"519\"><strong data-start=\"399\" data-end=\"476\">A special register (CR3 in x86) stores the base address of the page table</strong> so that the MMU can find it efficiently.</li><li data-start=\"520\" data-end=\"643\">Since page tables can be large, the OS uses <strong data-start=\"566\" data-end=\"588\">multi-level paging</strong> or <strong data-start=\"592\" data-end=\"616\">inverted page tables</strong> to reduce memory overhead.</li></ul><p data-start=\"645\" data-end=\"691\">ğŸ”¹ <strong data-start=\"648\" data-end=\"691\">How Does the CPU Access the Page Table?</strong></p><ol data-start=\"692\" data-end=\"1102\"><li data-start=\"692\" data-end=\"838\">When a program accesses a virtual address, the <strong data-start=\"742\" data-end=\"795\">MMU checks the Translation Lookaside Buffer (TLB)</strong>, a small <strong data-start=\"805\" data-end=\"837\">cache for page table entries</strong>.</li><li data-start=\"839\" data-end=\"888\">If the <strong data-start=\"849\" data-end=\"861\">TLB hits</strong>, the translation is quick.</li><li data-start=\"889\" data-end=\"984\">If the <strong data-start=\"899\" data-end=\"913\">TLB misses</strong>, the MMU walks the <strong data-start=\"933\" data-end=\"954\">page table in RAM</strong> to find the physical address.</li><li data-start=\"985\" data-end=\"1102\">If the <strong data-start=\"995\" data-end=\"1017\">page is not in RAM</strong>, a <strong data-start=\"1021\" data-end=\"1042\">page fault occurs</strong>, and the OS loads the required page from disk (swap space).</li></ol><hr data-start=\"1104\" data-end=\"1107\"><h3 data-start=\"1109\" data-end=\"1173\"><strong data-start=\"1113\" data-end=\"1171\">2. Is Contiguous Memory in Static Arrays Only Virtual?</strong></h3><p data-start=\"1174\" data-end=\"1284\">Yes! <strong data-start=\"1179\" data-end=\"1282\">Static arrays in programs are contiguous in virtual memory, but not necessarily in physical memory.</strong></p><p data-start=\"1286\" data-end=\"1297\">ğŸ”¹ <strong data-start=\"1289\" data-end=\"1297\">Why?</strong></p><ul data-start=\"1298\" data-end=\"1531\"><li data-start=\"1298\" data-end=\"1380\">Virtual memory allows processes to see a <strong data-start=\"1341\" data-end=\"1379\">logically contiguous address space</strong>.</li><li data-start=\"1381\" data-end=\"1469\">The <strong data-start=\"1387\" data-end=\"1468\">OS maps these virtual pages to physical frames, which can be scattered in RAM</strong>.</li><li data-start=\"1470\" data-end=\"1531\"><strong data-start=\"1472\" data-end=\"1513\">The program doesnâ€™t see fragmentation</strong>, but the OS does.</li></ul><p data-start=\"1533\" data-end=\"1568\">ğŸ”¹ <strong data-start=\"1536\" data-end=\"1548\">Example:</strong>\nImagine an array:</p><pre class=\"!overflow-visible\" data-start=\"1569\" data-end=\"1625\"><div class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\"><div class=\"flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-[5px] h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none\">cpp</div><div class=\"sticky top-9 md:top-[5.75rem]\"><div class=\"absolute bottom-0 right-2 flex h-9 items-center\"><div class=\"flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary\"><span class=\"\" data-state=\"closed\"><button class=\"flex gap-1 items-center select-none px-4 py-1\" aria-label=\"Copy\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"icon-xs\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z\" fill=\"currentColor\"></path></svg>Copy</button></span><span class=\"\" data-state=\"closed\"><button class=\"flex select-none items-center gap-1\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"icon-xs\"><path d=\"M2.5 5.5C4.3 5.2 5.2 4 5.5 2.5C5.8 4 6.7 5.2 8.5 5.5C6.7 5.8 5.8 7 5.5 8.5C5.2 7 4.3 5.8 2.5 5.5Z\" fill=\"currentColor\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path><path d=\"M5.66282 16.5231L5.18413 19.3952C5.12203 19.7678 5.09098 19.9541 5.14876 20.0888C5.19933 20.2067 5.29328 20.3007 5.41118 20.3512C5.54589 20.409 5.73218 20.378 6.10476 20.3159L8.97693 19.8372C9.72813 19.712 10.1037 19.6494 10.4542 19.521C10.7652 19.407 11.0608 19.2549 11.3343 19.068C11.6425 18.8575 11.9118 18.5882 12.4503 18.0497L20 10.5C21.3807 9.11929 21.3807 6.88071 20 5.5C18.6193 4.11929 16.3807 4.11929 15 5.5L7.45026 13.0497C6.91175 13.5882 6.6425 13.8575 6.43197 14.1657C6.24513 14.4392 6.09299 14.7348 5.97903 15.0458C5.85062 15.3963 5.78802 15.7719 5.66282 16.5231Z\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path><path d=\"M14.5 7L18.5 11\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></svg>Edit</button></span></div></div></div><div class=\"overflow-y-auto p-4\" dir=\"ltr\"><code class=\"!whitespace-pre language-cpp\"><span><span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">1000</span>];  <span class=\"hljs-comment\">// Assume each int is 4 bytes</span>\n</span></code></div></div></pre><ul data-start=\"1626\" data-end=\"1768\"><li data-start=\"1626\" data-end=\"1683\">This array has <strong data-start=\"1643\" data-end=\"1682\">contiguous virtual memory addresses</strong>.</li><li data-start=\"1684\" data-end=\"1768\">However, the physical memory might store these pages <strong data-start=\"1739\" data-end=\"1759\">non-contiguously</strong>, like:</li></ul><table data-start=\"1770\" data-end=\"1904\"><thead data-start=\"1770\" data-end=\"1805\"><tr data-start=\"1770\" data-end=\"1805\"><th data-start=\"1770\" data-end=\"1786\">Virtual Pages</th><th data-start=\"1786\" data-end=\"1805\">Physical Frames</th></tr></thead><tbody data-start=\"1839\" data-end=\"1904\"><tr data-start=\"1839\" data-end=\"1860\"><td>Page 0 â†’ Frame 10</td><td></td></tr><tr data-start=\"1861\" data-end=\"1882\"><td>Page 1 â†’ Frame 50</td><td></td></tr><tr data-start=\"1883\" data-end=\"1904\"><td>Page 2 â†’ Frame 22</td><td></td></tr></tbody></table><p data-start=\"1906\" data-end=\"1993\">The <strong data-start=\"1910\" data-end=\"1947\">program sees contiguous addresses</strong>, but <strong data-start=\"1953\" data-end=\"1992\">the OS maps them arbitrarily in RAM</strong>.</p><hr data-start=\"1995\" data-end=\"1998\"><h3 data-start=\"2000\" data-end=\"2021\"><strong data-start=\"2004\" data-end=\"2021\">Key Takeaways</strong></h3><p data-start=\"2022\" data-end=\"2314\">âœ… <strong data-start=\"2024\" data-end=\"2104\">Page tables are stored in RAM and managed by the OS, but accessed by the MMU</strong>.<br data-start=\"2105\" data-end=\"2108\">âœ… <strong data-start=\"2110\" data-end=\"2210\">Contiguous arrays in C/C++ are contiguous in virtual memory, but not necessarily in physical RAM</strong>.<br data-start=\"2211\" data-end=\"2214\">âœ… <strong data-start=\"2216\" data-end=\"2311\">The OS handles mapping virtual pages to physical frames, allowing non-contiguous allocation</strong>.</p><p data-start=\"2316\" data-end=\"2390\" data-is-last-node=\"\" data-is-only-node=\"\">Would you like more details on multi-level paging or TLB optimizations? ğŸš€</p></div>"
}