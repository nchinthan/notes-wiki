{
    "title": "dining philosophers",
    "html": "\n<p class=\"pageTitle\"><span style=\"color: var(--bs-heading-color,inherit); font-size: 2rem; font-family: var(--bs-body-font-family); text-align: var(--bs-body-text-align);\">Avoiding race conditions</span></p>\n\n<ul>\n<li><p>It's difficult to find a correct solution to the <a href=\"http://www.stolaf.edu/people/rab/OS/S18/racecond.html\">dining\nphilosophers</a> problem.  How can we avoid \nstarvation, deadlock, and race conditions?   Can we find an algorithm\nthat is fair (all philosophers get comparable opportunities to eat),\nhas a high degree of concurrency (e.g., allows multiple\nphilosophers to eat at the same time), and does not require\nphilosophers to wait long to eat when they're ready?  Will a solution\nremain feasible for a very large number of processors?</p></li>\n\n<li><p>Deadlock and starvation are very bad, but nothing compares to\ndebugging race conditions:  if the correct behavior of an algorithm\ndepends on \ntiming (definition of race condition), then incorrect behavior can't\nbe reproduced, because we can't expect exact duplication of a sporadic\nsequence of events.  </p></li>\n\n<li><p>Fortunately, the cause of race conditions is known:\n<em>between checking on a critical resource and acting on that check,\nanother process intervenes, making that check out of date and the\naction incorrect.</em>  For example, in the first <a href=\"http://www.stolaf.edu/people/rab/OS/S18/racecond2.html#dp3\">race condition example</a> for the\ndining philosophers problem, a race occurs during the <code>if</code>\nstatement \n</p><pre>   if (!myturn[p])\n      sleep()    /* to be awakened by prev philosopher */\n</pre>\nIf another process <em>B</em> changes <code>myturn[p]</code> to true\n<em>after</em> this process <em>A</em> evaluates the guard\n<code>(!myturn[p]</code> and <em>before</em> process <em>A</em> calls\n<code>sleep()</code>, then <em>B</em>'s <code>wakeup()</code> call may\nbe wasted before <em>A</em> has called <code>sleep()</code>, meaning\nthat there will be no way to wake up <em>A</em>.  Here, the guard \n<code>(!myturn[p]</code> is the \"check\" and the <code>sleep()</code>\ncall is the action that should only be perfomed if\n<code>myturn[p]</code> is false.\n<p></p></li>\n\n<li><p>Therefore, to avoid race conditions, we must somehow guarantee\nthat no process <em>B</em> can intervene during process <em>A</em>'s\nevaluation of conditionals that involve shared computing resources.  That would\nmake for an <em>atomic</em> (or <em>indivisible</em>) <code>if</code>\nstatement. \n</p></li>\n\n<li><p>One way to make operations indivisible is to locate them in a\nseparate <em>synchronization process</em> that receives requests and\nsends responses through message passing.  If all processes use the\nsynchronization process to access the shared resources, then the\nsynchronization process can guarantee that no two processes interfere\nwith each other to cause a race.</p></li>\n\n<li><p>There are other strategies for implementing atomicity for\ncorrect <em>interprocess communication</em> besides message-passing\napproaches.  But message passing fits parallel computing well,\nespecially in distributed computing environments (many of the other\nsolutions depend on all processes being on one computer and one\noperating system).</p></li>\n\n<li><p>______</p></li>\n\n</ul>\n\n<p>In the solutions to the Dining Philosophers problem below, we will\nassume that race conditions are avoided using some kind of atomicity\nstrategy.</p>\n\n<h2>The waiter solution to Dining Philosophers</h2>\n\n<ul>\n<li><p>The <strong>waiter solution</strong> provides a simple way to\nsolve the Dining Philosophers problem, assuming an external entity\ncalled the <em>waiter</em>.</p></li>\n\n<li><p>Strategy:</p>\n<ul>\n<li><p>Every philosopher must request each of their (shared)\nchopsticks from a waiter, who may refuse the request at first in order\nto avoid a deadlock. </p></li>\n\n<li><p>For convenience, we assume that all philosophers request their\nleft chopstick first, then their right chopstick.   </p></li>\n\n<li><p>The waiter always provides chopsticks upon request\n<em>unless</em> only one chopstick remains unused.  In that case, the\nwaiter honors the request only if a <em>right</em> chopstick is\nrequested;  requests for a left chopstick are <em>deferred</em> until\nanother philosopher finishes eating.  </p></li>\n\n</ul>\n</li>\n\n<li><p>Argument for correct <em>deadlock avoidance</em>:  The last\nchopstick will only be assigned if the waiter is certain that at least\none philosopher can finish eating (thereupon releasing chopsticks).\nTherefore, the \"circular wait\" required for deadlock can't occur.</p></li>\n\n<li><p>No starvation; fairness (depending on your waiter); degree of\nconcurrency...</p></li> \n\n<li><p>Downside: Scalability (the waiter could become a bottleneck if\nthe number of processors is large).  </p></li><li><p>the assignment of chopsticks is linear i.e only one chopstick can be assigned at a time.</p></li>\n\n</ul>\n\n\n<h2>Chandy-Misra solution</h2>\n\n<ul>\n<li><p>In 1984, K. Chandy and J. Misra proposed a solution to a\ngeneralized Dining Philosophers problem, which doesn't require the\nphilosophers to be in a circle or to share only two resources with\nonly nearest neighbors.</p></li>\n\n<li><p>Chandy-Misra's algorithm may be described in terms of \"clean\"\nand \"dirty\" chopsticks.  Each chopstick is shared with a pair of\nphilosophers.  </p> \n<ul>\n<li><p>Each chopstick is always <em>in the possession</em> of one of it's two\nphilosophers.  </p><p>Also, a dirty chopstick is <em>always cleaned just\nbefore it is given</em> to its other philosopher.</p></li>\n\n<li><p><em>Initialization.</em>  Every process receives a unique\ninteger ID number.  For every pair of philosophers who contend for a\nchopstick, one chopstick is created,  assigned to the philosopher\nwith the <em>lower</em> ID number (lower neighbor), and marked as\n\"dirty.\"</p></li>  \n<li><p><em>Thinking.</em>  When a philosopher <em>p</em> is thinking,\nif that philosopher <em>p</em> receives a \nrequest for a particular chopstick <em>c</em> from one of that philosopher's\nneighbors,  then <em>p</em> gives the neighbor that chopstick\n<em>c</em> (after cleaning it). </p></li>\n\n<li><p><em>Hungry.</em>  When a philosopher <em>p</em>\nis preparing to eat, <em>p</em> requests any chopsticks that <em>p</em> doesn't\nalready have from the appropriate neighbor.  </p>\n<p>During this\ntime, if a neighbor asks <em>p</em> for a chopstick that <em>p</em>\npossesses, then <em>p</em> <em>sends that chopstick</em> (after cleaning it) if\nit's dirty, and <em>keeps</em> that chopstick for the\npresent if it's clean.  <em>p</em>\n<em>defers</em> the requests for already-clean chopsticks (i.e.,\nremembers the clean requests for later delivery).</p></li> \n\n<li><p><em>Eating.</em>  A philosopher <em>p</em> may start eating as\nsoon as <em>p</em> has all of <em>p</em>'s chopsticks.  While eating,\nall requests for chopsticks are deferred, and all chopsticks become\ndirty.</p></li> \n\n<li><p><em>Cleanup.</em>  Immediately after eating, a philosopher\ndelivers any chopsticks for which there are deferred requests (after cleaning\nthem).  That philosopher then proceeds to eat.</p></li>\n\n\n</ul>\n\n</li>\n\n<li><p><em>Deadlock avoidance</em> of the Chandy-Misra algorithm can\nbe proven using directed graphs:  each philosopher represents a\nvertex, and each edge represents a chopstick, with an arrow going from\n\"dirty towards clean\".  The ID ordering of philosophers can be used to\nshow that this graph never has a closed cycles (i.e., deadlock\ncircular waits), by reassigning a (lower) ID to philosophers just\nafter they finish eating, thus insuring that the graph's arrows always\npoint from lower towards higher IDs.  </p></li>\n\n<li><p><em>No starvation:</em>  Since a hungry philosopher <em>p</em> always\nkeeps <em>p</em>'s clean chopsticks, and since each of <em>p</em>'s neighbors\nmust deliver their shared chopstick to <em>p</em>, cleaned, either\nimmediately (if the neighbor is thinking) or as soon as\nthat neighbor finishes eating, then we conclude that a hungry\nphilosopher <em>p</em> cannot be passed up more than once by any\nneighbor.  By transitivity, each of <em>p</em>'s hungry or eating\nneighbors must eventually finish eating, which guarantees that\n<em>p</em> won't starve.  (But <em>p</em> may have to fast for a long time.)\n</p></li> \n\n<li><p>Fairness (after eating, all resources are designated for the\nneighbors);  high degree of concurrency; scalable (because after\ninitialization; the resource management is local -- no central\nauthority needed);  generalizes to any number of processes and\nresources (as long as each resource is shared by exactly two\nprocesses). </p></li>\n\n<li><p>Downside:  potentially long wait chains when hungry.</p></li>\n\n</ul>\n\n\n<p class=\"footer\"><br></p>\n\n\n"
}